import java.util.Random;

public class ABDirtyAI extends AIModule{
    private int our_player;
    public int column;

    @Override
    public void getNextMove(final GameStateModule state){
	int i = 1;
    //int i = 2;
	final GameStateModule game = state.copy();

	while (!terminate){
	 //   System.out.print("depth: " + i + "\n\n");
	    interactiveDeepeningAlphaBetaSearch(game, i);
	    i++;
	}
    }

    public void interactiveDeepeningAlphaBetaSearch(final GameStateModule game, int depth){
	int v;
	our_player = game.getActivePlayer();

	v = maxValue(game, depth, -1*Integer.MAX_VALUE, Integer.MAX_VALUE);
	
	chosenMove = this.column;
    }

    public int maxValue(final GameStateModule game, int depth, int alpha, int beta){
	if (depth <= 0 || game.isGameOver()) return evaluationFunction(game); // terminal test (a function of the depth)

	int v = -1*Integer.MAX_VALUE;
	int v_aux;
	int[] moves = new int[game.getWidth()];
	int numLegalMoves = 0;

	// Fill in what moves are legal.
	for(int i = 0; i < game.getWidth(); ++i)
	{
	    if(game.canMakeMove(i))
		moves[numLegalMoves++] = i;
	}

	for (int i = 0; i < numLegalMoves && !terminate; i++){
	    game.makeMove(moves[i]);
	    v_aux = minValue(game, depth - 1, alpha, beta);
	    if(v_aux>v){v=v_aux; this.column = moves[i];}
	    game.unMakeMove();
	    if (v >= beta)
		return v;
	    alpha = max(alpha, v);
	}

	if(terminate){
	//    System.out.print("\n TERMINATE \n");
	    return Integer.MAX_VALUE;
	}else{
	    return v;
	}
    }

    public int minValue(final GameStateModule game, int depth, int alpha, int beta){
	if (depth <= 0 || game.isGameOver()) return evaluationFunction(game); // terminal test (a function of the depth)

	int v = -1*Integer.MAX_VALUE;
	int v_aux;
	int[] moves = new int[game.getWidth()];
	int numLegalMoves = 0;

	// Fill in what moves are legal.
	for(int i = 0; i < game.getWidth(); ++i)
	    if(game.canMakeMove(i))
		moves[numLegalMoves++] = i;

	for (int i = 0; i < numLegalMoves && !terminate; i++){
	    game.makeMove(moves[i]);
	    this.column = moves[i];
	    v_aux = maxValue(game, depth - 1, alpha, beta);
	    if(v_aux<v){v=v_aux; this.column = moves[i];}
	    game.unMakeMove();
	    if (v <= alpha)
		return v;
	    beta = min(beta, v);
	}

	if(terminate)
	{
	    System.out.print("\n TERMINATE \n");
	    return -1*Integer.MAX_VALUE;
	}
		else
	{
	    return v;
	}
    }

    public int max(int a, int b){
	return (a>b)?a:b;
    }

    public int min(int a, int b){
	return (a<b)?a:b;
    }

    public int evaluationFunction(final GameStateModule game)
	{
		int width = game.getWidth();
		int height = game.getHeight();
		int tmpPlayer = game.getActivePlayer();
		int tmp, k, twoSets, threeSets, opponentTwoSets, opponentThreeSets;
		twoSets = 0;
		threeSets = 0;
		opponentThreeSets = 0;
		opponentTwoSets = 0;
		// for each column
		for(int i = 0; i < width; i++)
			// for each row
			for(int j = 0; j < height; j++)
				// if not empty
				if(game.getAt(i,j) != 0)
				{
					for(int dx = -1; dx <= 1; dx++)

						for(int dy = -1; dy <= 1; dy++)
						{
							if(dx == 0 && dy == 0)
								continue;

							// If extent is out of bounds, abort.
							if(i + 3 * dx < 0 || i + 3 * dx >= width || j + 3 * dy < 0 || j + 3 * dy >= height)
								continue;


							k = 1;
							for(int step = 1; step <= 3; step++)
							{
								if(k == 2)
								{
									if(tmpPlayer == game.getAt(i,j))
										twoSets++;
									else
										opponentTwoSets++;
								}
								else if(k == 3)
								{
									if(tmpPlayer == game.getAt(i,j))
										threeSets++;
									else
										opponentThreeSets++;
								}
								if(game.getAt(i,j) != game.getAt(i + step * dx,j + step * dy))
								{
									k = 1;
									break;
								}

								k++;
							}
							if(k == 4)
							{
						//		System.out.print("VIC");
								if(game.getAt(i,j) == our_player)
								{
						//			System.out.print("w1k");
									tmp = 1000;
								}
								else
								{
						//			System.out.print("w-1k");
									tmp = -1000;
								}
						//		System.out.print("P");
								return tmp;
							}
						}
					}
					//	System.out.print("T" + threeSets+ "G" + twoSets);
						tmp = 3*threeSets + 2*twoSets - 3*opponentThreeSets - 2*opponentTwoSets;
					//	System.out.print("w" + tmp);
						return tmp;
				}
}
